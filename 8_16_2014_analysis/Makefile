#
# Some notes on file types that appear in the analysis
#
# .cache: A manifest of a given set of files on disk. These are generated to
# more easily metadata about the contents of files, and allow for easy
# sequential access to them, a process often needed by our analysis programs
#
# .gwf: Frame files containing the raw time series -- see notes later in this
# Makefile
#
# .xml.gz: gzipped XML documents: these generally contain either arrays of data
# (see for instance, all the PSD files) or more commonly a set of predefined 
# tables with columns of information (e.g. the trigger files).
#
# A few important tables are:
#
# sngl_burst: Short for single burst, and meant to repreesnt a time-frequency
# trigger generated by a filtering analysis on a single detector stream
#
# multi_burst: The final product of coincidence, describes a coincidence event
# between several instruments/channels.
#
# See:
#
# https://www.lsc-group.phys.uwm.edu/daswg/projects/glue/doc/glue.ligolw.lsctables-module.html
#
# for a complete listing.
#

.SECONDARY: open_v1p25_frames_resampled.cache open_v2p5_frames_resampled.cache open_v5_frames_resampled.cache open_v10_frames_resampled.cache shorten_v1p25_frames_resampled.cache shorten_v2p5_frames_resampled.cache shorten_v5_frames_resampled.cache shorten_v10_frames_resampled.cache 
.PHONY: clean all_ts_plots

# `LIGO style' detector prefix --- arbitrary and probably should be changed 
# because there will eventually be a K1 interferometer. For reference:
# K1 -- Krakow
# B1 -- Berkeley -- used in previous analyses
detector="K1"
# Input sampling rate
in_rate=1000
# Output sampling rate
out_rate=1024
# Duration of an individual frame file (see output format below)
output_stride=120
# Arbitary GPS timestamp for data to start at
gps_start=1000000000
gps_end_open=1000009600
gps_end_shorten=1000005880

#
# A note on channel names: Both the `open' and `shorten' data sets have four 
# columns of data corresponding to four different channels. The first two are
# partially shielded and the second are fully shielded. The names provided here
# are purely ad-hoc to be more descriptive and keep track of the individual time
# series as they are recorded in the frames. We should decide on (a possibly
# better) naming convention if this is not descriptive enough or totally
# inappropriate.
#

PSDS=K1-K1_MAG_v1p25-PART_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v1p25-PART_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v1p25-FULL_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v1p25-FULL_SHIELD_CHAN1_REF_PSD.xml.gz K1_MAG_v2p5-PART_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v2p5-PART_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v2p5-FULL_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v2p5-FULL_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v5-PART_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v5-PART_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v5-FULL_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v5-FULL_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v10-PART_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v10-PART_SHIELD_CHAN1_REF_PSD.xml.gz K1-K1_MAG_v10-FULL_SHIELD_CHAN2_REF_PSD.xml.gz K1-K1_MAG_v10-FULL_SHIELD_CHAN1_REF_PSD.xml.gz

#
# Preliminaries -- unpack the data if provided in tarball form
#
shorten:
	gunzip shorten.tgz

open:
	gunzip open.tgz

#
# Power spectra density (PSD) estimations for each channel and plotting them all
# together
#
plot_psds: ${PSDS}
	./plot_psds_single ${detector} ${PSDS}

K1-K1_MAG_%-PART_SHIELD_CHAN1_REF_PSD.xml.gz: open_%_frames_resampled.cache
	gstlal_reference_psd  \
        --data-source frames \
        --frame-cache $< \
        --channel-name K1=MAG-PART_SHIELD_CHAN1 \
        --gps-start-time 1000000000 \
        --gps-end-time 1000005880 \
        --sample-rate 1024 \
        --write-psd $@ \
        --verbose

K1-K1_MAG_%-PART_SHIELD_CHAN2_REF_PSD.xml.gz: open_%_frames_resampled.cache
	gstlal_reference_psd  \
        --data-source frames \
        --frame-cache $< \
        --channel-name K1=MAG-PART_SHIELD_CHAN2 \
        --gps-start-time 1000000000 \
        --gps-end-time 1000005880 \
        --sample-rate 1024 \
        --write-psd $@ \
        --verbose

K1-K1_MAG_%-FULL_SHIELD_CHAN1_REF_PSD.xml.gz: open_%_frames_resampled.cache
	gstlal_reference_psd  \
        --data-source frames \
        --frame-cache $< \
        --channel-name K1=MAG-FULL_SHIELD_CHAN1 \
        --gps-start-time 1000000000 \
        --gps-end-time 1000005880 \
        --sample-rate 1024 \
        --write-psd $@ \
        --verbose

K1-K1_MAG_%-FULL_SHIELD_CHAN2_REF_PSD.xml.gz: open_%_frames_resampled.cache
	gstlal_reference_psd  \
        --data-source frames \
        --frame-cache $< \
        --channel-name K1=MAG-FULL_SHIELD_CHAN2 \
        --gps-start-time 1000000000 \
        --gps-end-time 1000005880 \
        --sample-rate 1024 \
        --write-psd $@ \
        --verbose

#
# These rules explicitly convert the ASCII formatted data to 'gwf' formatted 
# data. More information on the gwf format can be found at
# https://dcc.ligo.org/LIGO-T970130/public
#
# The short story is that these are just binary containers for things like time
# series and other data --- LIGO rarely uses them for any thing but time series
#
# Implicitly: this also upsamples the data to the closest power of two, but this
# is controllable through the "out_rate" variable
#

open_%_frames_resampled.cache: open/%
	mkdir -p open_frames_resampled/$?/
	./makeframes -d $(detector) -i $(in_rate) -o $(out_rate) -c MAG-PART_SHIELD_CHAN1=1 -c MAG-PART_SHIELD_CHAN2=2 -c MAG-FULL_SHIELD_CHAN1=3 -c MAG-FULL_SHIELD_CHAN2=4 -s $(output_stride) -S $(gps_start) -D $< -O open_frames_resampled/$?/
	find open_frames_resampled/$?/ -name "*gwf" | lalapps_path2cache > $@

shorten_%_frames_resampled.cache: shorten/%
	mkdir -p shorten_frames_resampled/$?/
	./makeframes -d $(detector) -i $(in_rate) -o $(out_rate) -c MAG-PART_SHIELD_CHAN1=1 -c MAG-PART_SHIELD_CHAN2=2 -c MAG-FULL_SHIELD_CHAN1=3 -c MAG-FULL_SHIELD_CHAN2=4 -s $(output_stride) -S $(gps_start) -D $< -O shorten_frames_resampled/$?/
	find shorten_frames_resampled/$?/ -name "*gwf" | lalapps_path2cache > $@


#
# Plot the time series data we just made
#
open_%_frames_resampled.png: open_%_frames_resampled.cache
	./plot_ts $<

shorten_%_frames_resampled.png: shorten_%_frames_resampled.cache
	./plot_ts $<

all_ts_plots: shorten_v1p25_frames_resampled.png shorten_v2p5_frames_resampled.png shorten_v5_frames_resampled.png shorten_v10_frames_resampled.png open_v1p25_frames_resampled.png open_v2p5_frames_resampled.png open_v5_frames_resampled.png open_v10_frames_resampled.png

#
# Analysis rules
#
MAG_PART_SHIELD_CHAN1_open: gnome_test_open.ini open_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache open_frames_resampled.cache \
        --channel-name K1=MAG_PART_SHIELD_CHAN1 \
        --sample-rate 1024 \
        --initialization-file gnome_test_open.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_open} \
        --verbose

MAG_PART_SHIELD_CHAN2_open: gnome_test_open.ini open_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache open_frames_resampled.cache \
        --channel-name K1=MAG_PART_SHIELD_CHAN2 \
        --sample-rate 1024 \
        --initialization-file gnome_test_open.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_open} \
        --verbose

MAG_FULL_SHIELD_CHAN1_open: gnome_test_open.ini open_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache open_frames_resampled.cache \
        --channel-name K1=MAG_FULL_SHIELD_CHAN1 \
        --sample-rate 1024 \
        --initialization-file gnome_test_open.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_open} \
        --verbose

MAG_FULL_SHIELD_CHAN2_open: gnome_test_open.ini open_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache open_frames_resampled.cache \
        --channel-name K1=MAG_FULL_SHIELD_CHAN2 \
        --sample-rate 1024 \
        --initialization-file gnome_test_open.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_open} \
        --verbose

MAG_PART_SHIELD_CHAN1_shorten: gnome_test_shorten.ini shorten_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache shorten_frames_resampled.cache \
        --channel-name K1=MAG_PART_SHIELD_CHAN1 \
        --sample-rate 1024 \
        --initialization-file gnome_test_shorten.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_shorten} \
        --verbose

MAG_PART_SHIELD_CHAN2_shorten: gnome_test_shorten.ini shorten_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache shorten_frames_resampled.cache \
        --channel-name K1=MAG_PART_SHIELD_CHAN2 \
        --sample-rate 1024 \
        --initialization-file gnome_test_shorten.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_shorten} \
        --verbose

MAG_FULL_SHIELD_CHAN1_shorten: gnome_test_shorten.ini shorten_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache shorten_frames_resampled.cache \
        --channel-name K1=MAG_FULL_SHIELD_CHAN1 \
        --sample-rate 1024 \
        --initialization-file gnome_test_shorten.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_shorten} \
        --verbose

MAG_FULL_SHIELD_CHAN2_shorten: gnome_test_shorten.ini shorten_frames_resampled.cache
	gstlal_excesspower  \
        --data-source frames \
        --frame-cache shorten_frames_resampled.cache \
        --channel-name K1=MAG_FULL_SHIELD_CHAN2 \
        --sample-rate 1024 \
        --initialization-file gnome_test_shorten.ini \
        --gps-start-time ${gps_start} \
        --gps-end-time ${gps_end_shorten} \
        --verbose

analysis_open: MAG_PART_SHIELD_CHAN1_open MAG_PART_SHIELD_CHAN2_open MAG_FULL_SHIELD_CHAN1_open MAG_FULL_SHIELD_CHAN2_open

analysis_shorten: MAG_PART_SHIELD_CHAN1_shorten MAG_PART_SHIELD_CHAN2_shorten MAG_FULL_SHIELD_CHAN1_shorten MAG_FULL_SHIELD_CHAN2_shorten

analysis: analysis_open analysis_shorten

#
# Locate and manifest all the trigger files
#
open_triggers.cache:
	find open_triggers/ | lalapps_path2cache > open_triggers.cache
shorten_triggers.cache:
	find shorten_triggers/ | lalapps_path2cache > shorten_triggers.cache

#
# Some notes on clustering:
#
# ligolw_bucluster : A BUrst CLUSTERing algorithm using LIGOLW XML documents
#
# This algorithm takes the tiles produces by a time-frequency analysis (e.g.
# gstlal_excesspower) and 'clusters' them. That is, it identifies tiles which
# overlap on the T-F plane and agglomerates them into a larger tile with time /
# frequency properties which are weighted (by tile energy) averages of the
# clustered tiles. This process is associative, and so:
#
# cluster(cluster(A, B), C) = cluster(A, cluster(B,C))
#
# This process ensures that the same clustered tile is produces from a
# colleciton of overlapping tiles, regardless of their order or appearance in a
# given file.
#
# Finally, the clustered tile (now considered to be an event trigger) also has
# a set of statistical significance information associated with it. More
# concisely, the most statistically significant tile in the collection has its 
# vital information saved with the other trigger information. This is an attempt
# to best localize the signal on the time-frequency plane, as well as probe its
# full T-F extent.
#
open_triggers_clustered.cache:
	cp -r open_triggers/ open_triggers_clustered/
	find open_triggers_clustered/ | lalapps_path2cache > .$@
	ligolw_bucluster --cluster-algorithm excesspower --program gstlal_excesspower --verbose --input-cache .$@
	mv .$@ $@

shorten_triggers_clustered.cache:
	cp -r shorten_triggers/ shorten_triggers_clustered/
	find shorten_triggers_clustered/ | lalapps_path2cache > .$@
	ligolw_bucluster --cluster-algorithm excesspower --program gstlal_excesspower --verbose --input-cache .$@
	mv .$@ $@

#
# Some notes on coincidence:
#
# ligolw_burca : The BURst Coincidence Algorithm, uses LIGOLW XML files
#
# In LSC searches, ligolw_burca is used to check coincidences between triggers
# in different instruments. It is nominally give a 'time_slide' table which
# describes all possible time offsets between any given pair of instruments.
# This is combined with the known GW travel time (light travel time) between 
# instruments to determine  if 'coincidence' between triggers is possible. 
#
# Additional time offsets greater than the GW travel time are used to construct
# 'control' coincidence sets which are used for false alarm rate / background 
# analysis
#
# The program which does coincidence in LSC searches for generic transients has
# some shortcomings which prevent it from being used out of the box: 
# For one it has hardcoded GW travel times for specific instruments used in GW 
# data analysis -- in other words, it has no concept of the magnetometer 
# locations used for GNOME analysis.
#
# Workaround: The program has been specially modified to insert a dummy location
# for Krakow, specifically the coordinates of Jagiellonian University, as given
# by wikipedia have been converted to match the convention of other instrument
# locations. This is enough to calculate the light travel time.
#
# Another shortcoming is that the coincidence algorithm is designed to
# coincide different *instruments* not different channels coming from the same
# instrument. The distinction is not obvious, but there's real reason to be
# able to do this in practice.
#
# Workaround: Each channel's triggers 'ifo' column (a misnomer here because
# we're interferometric-centric) has been modified to be unique to a given
# given channel. E.g.
# K1:MAG-FULL_SHIELD_CHAN2 => K4:MAG-FULL_SHIELD_CHAN2
#
# So really, each channel is being given it's own instrument. Eventually, I'll
# need to rewrite the underlying coincidence algorithms to be able to coincide
# between channels and instruments, but that will take some time.
#
# This work around is accomplished with a small utility script called
# munge_inst_name
#

# ligolw_tisi: produces a LIGOLW XML document with a set of unique time offsets
# per instrument, used in a for a TIme SlIde analysis
time_slide_table.xml.gz:
	ligolw_tisi -i K1=0:5:1 -i K2=0:5:1 -i K3=0:5:1 -i K4=0:0:1 -v time_slide_table.xml.gz 

K-ALL_TRIGGERS_COINC_SHORTEN.xml.gz: time_slide_table.xml.gz shorten_triggers_clsutered.cache
	ligolw_add  \ 
	    --input-cache shorten_triggers_clustered.cache \
        --verbose  \
        -o .tmp_coinc.xml.gz  \
        time_slide_table.xml.gz
	./munge_inst_name \
	./ligolw_burca_gnome \
        --coincidence-algorithm excesspower \
        -t K1,K2=0 -t K1,K3=0 -t K1,K4=0 -t K2,K3=0 -t K2,K4=0 -t K3,K4=0  \
        --verbose \
        .tmp_coinc.xml.gz \
	mv .tmp_coinc.xml.gz $@

K-ALL_TRIGGERS_COINC_OPEN.xml.gz: time_slide_table.xml.gz open_triggers_clustered.cache
	ligolw_add  \ 
	    --input-cache open_triggers_clustered.cache \
        --verbose  \
        -o .tmp_coinc.xml.gz  \
        time_slide_table.xml.gz
	./munge_inst_name \
	./ligolw_burca_gnome \
        --coincidence-algorithm excesspower \
        -t K1,K2=0 -t K1,K3=0 -t K1,K4=0 -t K2,K3=0 -t K2,K4=0 -t K3,K4=0  \
        --verbose \
        .tmp_coinc.xml.gz \
	mv .tmp_coinc.xml.gz $@

clean:
	rm -rf *.cache 
	rm -rf *.xml.gz 
	rm -rf *.png
	rm -rf open_frames_resampled
	rm -rf shorten_frames_resampled
